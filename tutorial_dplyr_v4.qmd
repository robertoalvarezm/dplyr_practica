---
title: "Aprendiendo `dplyr` paso a paso"
subtitle: "Con datos reales de salud ‚Äî Variables categ√≥ricas y valores NA"
author: "Fuente: dataset_categorical_NA.csv"
date: today
lang: es
format:
  html:
    toc: true
    toc-depth: 3
    toc-title: "üìã Contenido"
    theme: flatly
    code-fold: false
    code-tools: true
    highlight-style: github
    fig-width: 8
    fig-height: 5
    fig-align: center
    out-width: "80%"
    self-contained: true
    number-sections: true
execute:
  echo: true
  warning: false
  message: false
---

```{r setup, include=FALSE}
library(dplyr)
library(readr)
library(ggplot2)
library(tidyr)
```

# ¬øPor qu√© aprender `dplyr`? {.unnumbered}

Si ya conoces R base, sabes que se puede hacer casi todo con √©l. El problema es que conforme los an√°lisis crecen, el c√≥digo se vuelve dif√≠cil de leer y de mantener.

`dplyr` es parte del ecosistema **tidyverse** y te da una forma consistente y legible de manipular tablas. No reemplaza a R base: lo complementa. Es R base con mejores modales.

El vocabulario de `dplyr` son **6 verbos** principales. Una vez que los dominas, puedes hacer an√°lisis complejos escribiendo c√≥digo que casi se lee como espa√±ol.

```{r, eval=FALSE}
# Instalar si a√∫n no tienes los paquetes (una sola vez):
install.packages("tidyverse")
```

```{r}
library(dplyr)
library(readr)
library(ggplot2)
library(tidyr)
```

---

# Los datos que usaremos

## Dataset: Indicadores de salud con variables categ√≥ricas

El archivo `dataset_categorical_NA.csv` contiene registros de individuos con mediciones cl√≠nicas, h√°bitos de vida y caracter√≠sticas sociodemogr√°ficas. Incluye valores `NA` (datos faltantes) ‚Äî una situaci√≥n muy frecuente en datos reales de salud.

Cada fila representa un **paciente o participante**. Las columnas se dividen en dos grandes grupos:

**Variables num√©ricas (mediciones cl√≠nicas):**

| Columna | Descripci√≥n |
|---|---|
| `Age` | Edad (a√±os) |
| `Weight` | Peso (kg) |
| `Height` | Altura (cm) |
| `BMI` | √çndice de Masa Corporal |
| `BloodPressure` | Presi√≥n arterial |
| `Cholesterol` | Colesterol total |
| `Glucose` | Glucosa en sangre |
| `HeartRate` | Frecuencia card√≠aca |
| `BodyFat` | Porcentaje de grasa corporal |
| `MuscleMass` | Masa muscular |
| `WaistCircumference` | Circunferencia de cintura (cm) |
| `HipCircumference` | Circunferencia de cadera (cm) |
| `ActivityLevel` | Nivel de actividad f√≠sica |
| `SleepHours` | Horas de sue√±o |
| `AlcoholIntake` | Consumo de alcohol |
| `DietQuality` | Calidad de la dieta |
| `StressLevel` | Nivel de estr√©s |
| `MedicationUse` | Uso de medicamentos |
| `FamilyHistory` | Antecedentes familiares |
| `IncomeLevel` | Nivel de ingreso |

**Variables categ√≥ricas (caracter√≠sticas sociodemogr√°ficas):**

| Columna | Descripci√≥n | Valores posibles |
|---|---|---|
| `SmokingStatus` | Estatus de tabaquismo | `Fuma`, `No fuma`, `Ex-fumadora` |
| `EducationLevel` | Nivel educativo | `Preparatoria`, `Posgrado`, etc. |
| `MaritalStatus` | Estado civil | `Casada`, `Divorciada`, `Uni√≥n libre`, etc. |
| `EmploymentStatus` | Situaci√≥n laboral | `Tiempo completo`, `Estudiante`, etc. |
| `ResidenceType` | Tipo de residencia | `Urbano`, `Suburbano`, `Rural` |

```{r cargar-datos}
# Cargamos el dataset desde archivo local
salud <- read_csv("dataset_categorical_NA.csv", show_col_types = FALSE)

glimpse(salud)
```

```{r explorar-nas}
# ¬øCu√°ntos valores NA hay por columna?
salud |>
  summarise(across(everything(), ~ sum(is.na(.)))) |>
  pivot_longer(everything(), names_to = "columna", values_to = "n_NA") |>
  filter(n_NA > 0) |>
  arrange(desc(n_NA))
```

> üí° **Nota sobre los NA:** Los valores faltantes son una realidad del trabajo con datos de salud. `dplyr` los respeta y los propaga en los c√°lculos. Cuando sea necesario ignorarlos usaremos `na.rm = TRUE` dentro de las funciones de resumen.

---

# El pipe `|>`

Antes de entrar a los verbos, necesitamos entender el **pipe** (`|>`), porque lo usaremos constantemente.

## ¬øQu√© problema resuelve?

En R base, aplicar varias operaciones seguidas obliga a anidar funciones ‚Äî hay que leerlas de adentro hacia afuera:

```{r}
# R BASE: seleccionar columnas y ver las primeras filas
# Lees de adentro hacia afuera: primero select, luego head
head(salud[, c("SmokingStatus", "BMI", "Age")], 5)
```

El pipe `|>` te permite escribir las mismas operaciones **de arriba a abajo**, como una receta:

```{r}
# CON PIPE: mismo resultado, se lee de izquierda a derecha
salud |>
  select(SmokingStatus, BMI, Age) |>
  head(5)
```

El pipe toma lo que est√° a su izquierda y lo pasa como **primer argumento** a la funci√≥n de la derecha. Estos dos son equivalentes:

```{r eval=FALSE}
filter(salud, SmokingStatus == "Fuma")
salud |> filter(SmokingStatus == "Fuma")
```

> **Atajo de teclado:** `Ctrl+Shift+M` (Win/Linux) ¬∑ `Cmd+Shift+M` (Mac)  
> En *Tools ‚Üí Global Options ‚Üí Code* activa *"Use native pipe operator (`|>`)"*.

---

# Verbo 1: `filter()` ‚Äî Quedarte solo con ciertas filas

## La idea

`filter()` te deja solo con las filas que cumplen una condici√≥n. Es el equivalente de `[condici√≥n, ]` en R base, pero m√°s legible.

```{r}
# R BASE: participantes que fuman
salud[salud$SmokingStatus == "Fuma", c("ID", "SmokingStatus", "Age", "BMI")] |> head(3)

# DPLYR: mismo resultado, m√°s claro
filter(salud, SmokingStatus == "Fuma") |>
  select(ID, SmokingStatus, Age, BMI) |>
  head(3)
```

Nota que dentro de `filter()` no necesitas escribir `salud$SmokingStatus` ‚Äî R ya sabe a qu√© tabla te refieres.

## Una condici√≥n

```{r}
# Solo los que fuman
filter(salud, SmokingStatus == "Fuma")
```

```{r}
# Participantes con IMC mayor a 30 (obesidad)
filter(salud, BMI > 30)
```

## Dos condiciones con AND

La coma dentro de `filter()` equivale al `&` ‚Äî ambas condiciones deben cumplirse:

```{r}
# Participantes que fuman Y tienen IMC > 25
filter(salud, SmokingStatus == "Fuma", BMI > 25) |>
  select(ID, SmokingStatus, BMI, Age) |>
  head(8)
```

## Condici√≥n OR con `|`

Al menos una de las dos condiciones debe cumplirse:

```{r}
# Participantes con presi√≥n arterial alta O colesterol alto
filter(salud, BloodPressure > 80 | Cholesterol > 80) |>
  select(ID, BloodPressure, Cholesterol, SmokingStatus) |>
  head(8)
```

## Filtrar por varios valores: `%in%`

Cuando quieres varios valores de la misma columna, `%in%` es m√°s limpio que encadenar `|`:

```{r}
# Participantes con educaci√≥n universitaria o de posgrado
filter(salud, EducationLevel %in% c("Universidad", "Posgrado")) |>
  count(EducationLevel)
```

## Filtrar por rango: `between()`

```{r}
# Participantes en edad laboral (25 a 55 a√±os)
filter(salud, between(Age, 25, 55)) |>
  select(ID, Age, EmploymentStatus) |>
  head(8)
```

## Manejar NA en los filtros

Al filtrar, los NA no son ni `TRUE` ni `FALSE`, por lo que se excluyen silenciosamente:

```{r}
# Incluir expl√≠citamente los NA en un filtro
filter(salud, is.na(Age) | Age < 30) |>
  select(ID, Age, SmokingStatus)
```

## Encadenando filtros con el pipe

```{r}
# Participantes urbanos, empleados de tiempo completo, sin historial familiar de enfermedades
salud |>
  filter(ResidenceType == "Urbano") |>
  filter(EmploymentStatus == "Tiempo completo") |>
  filter(FamilyHistory < 20) |>
  select(ID, Age, BMI, SmokingStatus, ResidenceType) |>
  head(10)
```

> ‚ö†Ô∏è **Error frecuente:** `=` vs `==`  
> ```r
> filter(salud, SmokingStatus = "Fuma")   # ‚ùå Error: = es asignaci√≥n
> filter(salud, SmokingStatus == "Fuma")  # ‚úÖ Correcto: == es comparaci√≥n
> ```

---

::: {.callout-note icon=false}
## üèãÔ∏è Ejercicios ‚Äî `filter()`

**1.** ¬øCu√°ntos participantes son ex-fumadores?

**2.** Filtra los participantes con nivel de estr√©s mayor a 80. ¬øQu√© estatus de tabaquismo predomina entre ellos?

**3.** ¬øCu√°ntos participantes tienen m√°s de 40 a√±os Y residen en zona urbana?  
*Pista:* usa la coma para combinar condiciones.

**4.** Filtra los participantes con posgrado o preparatoria que trabajen tiempo completo.

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluciones

```{r}
# 1. Conteo de ex-fumadores
filter(salud, SmokingStatus == "Ex-fumadora") |> nrow()

# 2. Estr√©s alto y tabaquismo
filter(salud, StressLevel > 80) |>
  count(SmokingStatus, sort = TRUE)

# 3. Mayores de 40 en zona urbana
filter(salud, Age > 40, ResidenceType == "Urbano") |> nrow()

# 4. Posgrado o preparatoria + tiempo completo
filter(salud,
       EducationLevel %in% c("Posgrado", "Preparatoria"),
       EmploymentStatus == "Tiempo completo") |>
  select(ID, EducationLevel, EmploymentStatus, Age)
```
:::

---

# Verbo 2: `select()` ‚Äî Quedarte solo con ciertas columnas

## La idea

`filter()` trabaja con **filas**. `select()` trabaja con **columnas**. Si tienes una tabla con 26 columnas y solo necesitas 5, usa `select()`.

```{r}
# R BASE: seleccionar columnas
salud[, c("ID", "Age", "BMI", "SmokingStatus", "ResidenceType")]

# DPLYR: sin comillas, sin c()
select(salud, ID, Age, BMI, SmokingStatus, ResidenceType)
```

## Selecci√≥n b√°sica

```{r}
salud |>
  select(ID, Age, BMI, SmokingStatus, EducationLevel, ResidenceType) |>
  head(5)
```

## Excluir columnas con `-`

```{r}
# Nos quedamos con todo menos el ID y las medidas corporales directas
salud |>
  select(-ID, -Weight, -Height, -WaistCircumference, -HipCircumference) |>
  names()
```

## Renombrar al seleccionar

La sintaxis es `nuevo_nombre = nombre_original`:

```{r}
salud |>
  select(
    participante   = ID,
    edad           = Age,
    imc            = BMI,
    tabaquismo     = SmokingStatus,
    educacion      = EducationLevel,
    residencia     = ResidenceType
  ) |>
  head(5)
```

## Helpers: seleccionar por patr√≥n

```{r}
# Columnas que contienen "Circumference"
salud |>
  select(ID, contains("Circumference")) |>
  head(5)
```

```{r}
# Solo columnas num√©ricas
salud |>
  select(where(is.numeric)) |>
  head(3)
```

```{r}
# Solo columnas de texto (categ√≥ricas)
salud |>
  select(where(is.character)) |>
  head(3)
```

### Tabla de helpers de `select()`

| Helper | ¬øQu√© selecciona? |
|---|---|
| `starts_with("x")` | Nombres que empiezan con "x" |
| `ends_with("x")` | Nombres que terminan con "x" |
| `contains("x")` | Nombres que contienen "x" |
| `where(is.numeric)` | Columnas num√©ricas |
| `where(is.character)` | Columnas de texto |

## `filter()` + `select()` juntos

Patr√≥n muy com√∫n: filtra las filas de inter√©s, luego qu√©date con las columnas relevantes:

```{r}
salud |>
  filter(SmokingStatus == "Fuma", ResidenceType == "Urbano") |>
  select(ID, Age, BMI, Cholesterol, BloodPressure) |>
  head(8)
```

---

::: {.callout-note icon=false}
## üèãÔ∏è Ejercicios ‚Äî `select()`

**1.** Selecciona solo las columnas categ√≥ricas (`where(is.character)`) del dataset `salud`.

**2.** Selecciona `ID`, `Age` y todas las columnas que contienen medidas de circunferencia. Renombra `WaistCircumference` como `cintura`.

**3.** Filtra solo los participantes de zona rural y luego selecciona √∫nicamente `ID`, `Age`, `BMI` y `SmokingStatus`.

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluciones

```{r}
# 1. Columnas de texto
salud |> select(where(is.character)) |> head(3)

# 2. Columnas de circunferencia renombradas
salud |>
  select(ID, Age, cintura = WaistCircumference, HipCircumference) |>
  head(5)

# 3. Participantes rurales
salud |>
  filter(ResidenceType == "Rural") |>
  select(ID, Age, BMI, SmokingStatus) |>
  head(8)
```
:::

---

# Verbo 3: `arrange()` ‚Äî Ordenar filas

## La idea

`arrange()` ordena las filas seg√∫n los valores de una o varias columnas. Por defecto: menor a mayor. Para invertir: `desc()`.

```{r}
# R BASE: ordenar de mayor a menor por BMI
salud[order(-salud$BMI, na.last = TRUE), c("ID", "Age", "BMI", "SmokingStatus")] |> head(5)

# DPLYR: m√°s claro
salud |>
  select(ID, Age, BMI, SmokingStatus) |>
  arrange(desc(BMI)) |>
  head(5)
```

## De menor a mayor (default)

```{r}
salud |>
  select(ID, Age, BMI, BloodPressure) |>
  arrange(Age) |>
  head(6)
```

## De mayor a menor: `desc()`

```{r}
# ¬øQui√©nes tienen mayor nivel de colesterol?
salud |>
  select(ID, Age, Cholesterol, SmokingStatus, EducationLevel) |>
  arrange(desc(Cholesterol)) |>
  head(8)
```

## Ordenar por m√∫ltiples columnas

La segunda columna act√∫a como desempate:

```{r}
# Primero por estatus de tabaquismo (A-Z), dentro de cada grupo por IMC descendente
salud |>
  filter(!is.na(SmokingStatus)) |>
  select(ID, SmokingStatus, BMI, Age) |>
  arrange(SmokingStatus, desc(BMI)) |>
  head(10)
```

> üí° **Nota sobre NA en `arrange()`:** Los valores `NA` siempre van al final por defecto, tanto en orden ascendente como descendente.

---

::: {.callout-note icon=false}
## üèãÔ∏è Ejercicios ‚Äî `arrange()`

**1.** ¬øQu√© participante tiene el nivel de glucosa m√°s alto? Muestra el top 5.

**2.** Ordena los participantes que fuman por edad (ascendente) y dentro de cada edad por BMI (descendente). Muestra las primeras 10 filas.

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluciones

```{r}
# 1. Top 5 glucosa m√°s alta
salud |>
  select(ID, Age, Glucose, SmokingStatus) |>
  arrange(desc(Glucose)) |>
  head(5)

# 2. Fumadores ordenados por edad y BMI
salud |>
  filter(SmokingStatus == "Fuma") |>
  select(ID, Age, BMI, SmokingStatus) |>
  arrange(Age, desc(BMI)) |>
  head(10)
```
:::

---

# Verbo 4: `mutate()` ‚Äî Crear o modificar columnas

## La idea

`mutate()` a√±ade columnas nuevas calculadas a partir de las que ya existen, o modifica las existentes. No quita ni agrega filas.

```{r}
# R BASE: crear columna nueva
salud$riesgo_metabolico <- salud$BMI + salud$BloodPressure

# DPLYR: sin modificar el original (necesitas reasignar para guardar)
salud |>
  mutate(riesgo_metabolico = BMI + BloodPressure) |>
  select(ID, BMI, BloodPressure, riesgo_metabolico) |>
  head(5)
```

> üí° `mutate()` **no modifica el objeto original**. Para guardar los cambios: `salud <- salud |> mutate(...)`

## Crear varias columnas a la vez

```{r}
salud <- salud |>
  mutate(
    # √çndice combinado de riesgo cardiovascular (simplificado)
    riesgo_cardio  = round((BloodPressure + Cholesterol) / 2, 1),
    # Relaci√≥n cintura-cadera (indicador de distribuci√≥n de grasa)
    ratio_cc       = round(WaistCircumference / HipCircumference, 3)
  )

salud |>
  select(ID, BloodPressure, Cholesterol, riesgo_cardio, WaistCircumference, HipCircumference, ratio_cc) |>
  arrange(desc(riesgo_cardio)) |>
  head(6)
```

## Clasificaciones binarias: `ifelse()`

```{r}
salud <- salud |>
  mutate(
    obesidad = ifelse(BMI >= 30, "S√≠", "No")
  )

count(salud, SmokingStatus, obesidad)
```

## Clasificaciones m√∫ltiples: `case_when()`

`case_when()` es como un `if-else` encadenado. La sintaxis: `condici√≥n ~ valor`. El `TRUE` al final act√∫a como "else":

```{r}
salud <- salud |>
  mutate(
    categoria_imc = case_when(
      is.na(BMI)        ~ "Sin dato",
      BMI < 18.5        ~ "Bajo peso",
      BMI < 25          ~ "Normal",
      BMI < 30          ~ "Sobrepeso",
      TRUE              ~ "Obesidad"
    )
  )

count(salud, categoria_imc, sort = TRUE)
```

> ‚ö†Ô∏è **Importante con NA:** Si no manejas los `NA` expl√≠citamente en `case_when()` como primera condici√≥n (`is.na(...) ~ "Sin dato"`), los registros sin dato caer√°n en el `TRUE` y se clasificar√°n incorrectamente.

## Clasificar el estr√©s por niveles

```{r}
salud <- salud |>
  mutate(
    nivel_estres = case_when(
      is.na(StressLevel)    ~ "Sin dato",
      StressLevel < 30      ~ "Bajo",
      StressLevel < 60      ~ "Moderado",
      StressLevel < 80      ~ "Alto",
      TRUE                  ~ "Muy alto"
    )
  )

count(salud, nivel_estres) |> arrange(nivel_estres)
```

## Transformaciones matem√°ticas √∫tiles

```{r}
# Centrar la edad respecto a la media del grupo (√∫til para an√°lisis)
salud |>
  filter(!is.na(Age)) |>
  mutate(
    edad_centrada = round(Age - mean(Age, na.rm = TRUE), 1)
  ) |>
  select(ID, Age, edad_centrada, SmokingStatus) |>
  arrange(desc(Age)) |>
  head(8)
```

---

::: {.callout-note icon=false}
## üèãÔ∏è Ejercicios ‚Äî `mutate()`

**1.** Crea una columna `grupo_edad` que clasifique a los participantes en:  
- Menos de 30: `"Joven"` ¬∑ Entre 30‚Äì50: `"Adulto"` ¬∑ M√°s de 50: `"Mayor"`  
*Pista:* usa `case_when()`. Recuerda manejar los `NA`.

**2.** Crea una columna `fumador` que indique `TRUE` si el participante fuma actualmente (`SmokingStatus == "Fuma"`), `FALSE` en caso contrario.

**3.** Crea una columna `imc_normalizado` que calcule cu√°ntos puntos de BMI tiene cada participante por encima o por debajo de la media del grupo.

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluciones

```{r}
# 1. Columna grupo_edad
salud |>
  mutate(
    grupo_edad = case_when(
      is.na(Age)  ~ "Sin dato",
      Age < 30    ~ "Joven",
      Age <= 50   ~ "Adulto",
      TRUE        ~ "Mayor"
    )
  ) |>
  count(grupo_edad)

# 2. Columna fumador (l√≥gica)
salud |>
  mutate(fumador = SmokingStatus == "Fuma") |>
  count(fumador)

# 3. IMC normalizado respecto a la media
salud |>
  mutate(
    imc_normalizado = round(BMI - mean(BMI, na.rm = TRUE), 2)
  ) |>
  select(ID, BMI, imc_normalizado, categoria_imc) |>
  arrange(desc(imc_normalizado)) |>
  head(8)
```
:::

---

# Verbo 5: `summarise()` ‚Äî Resumir datos

## La idea

`summarise()` **colapsa** todo el data frame a una sola fila de estad√≠sticas. Es como hacer `mean()`, `sum()`, etc. en R base, pero de forma organizada.

```{r}
# R BASE
c(
  n           = nrow(salud),
  media_imc   = mean(salud$BMI,  na.rm = TRUE),
  media_edad  = mean(salud$Age,  na.rm = TRUE),
  max_colest  = max(salud$Cholesterol, na.rm = TRUE)
)

# DPLYR: m√°s organizado y extendible
salud |>
  summarise(
    n               = n(),
    media_imc       = round(mean(BMI, na.rm = TRUE), 1),
    mediana_imc     = round(median(BMI, na.rm = TRUE), 1),
    media_edad      = round(mean(Age, na.rm = TRUE), 1),
    max_colesterol  = round(max(Cholesterol, na.rm = TRUE), 1),
    n_sin_edad      = sum(is.na(Age))
  )
```

> üí° **`na.rm = TRUE`:** Siempre a√±√°delo cuando el dataset tiene NA y quieres calcular estad√≠sticas sobre columnas num√©ricas. Sin √©l, cualquier NA en la columna hace que el resultado sea `NA`.

### Funciones √∫tiles dentro de `summarise()`

| Funci√≥n | ¬øQu√© hace? |
|---|---|
| `n()` | Cuenta filas |
| `n_distinct(x)` | Cuenta valores √∫nicos |
| `sum(x, na.rm=TRUE)` | Suma (ignorando NA) |
| `mean(x, na.rm=TRUE)` | Promedio |
| `median(x, na.rm=TRUE)` | Mediana |
| `sd(x, na.rm=TRUE)` | Desviaci√≥n est√°ndar |
| `min(x, na.rm=TRUE)` / `max(x, na.rm=TRUE)` | M√≠nimo / M√°ximo |
| `sum(is.na(x))` | Cuenta los NA |

---

# Verbo 6: `group_by()` + `summarise()` ‚Äî Res√∫menes por grupo

## La idea

Esta es la combinaci√≥n m√°s poderosa de `dplyr`. `group_by()` pone separadores invisibles en la tabla; `summarise()` calcula estad√≠sticos **dentro de cada grupo**.

Pi√©nsalo como carpetas: `group_by()` pone las divisiones, `summarise()` saca las cuentas de cada secci√≥n.

```{r}
# R BASE: promedio de BMI por estatus de tabaquismo
tapply(salud$BMI, salud$SmokingStatus, mean, na.rm = TRUE)

# DPLYR: m√°s claro y f√°cilmente extendible
salud |>
  group_by(SmokingStatus) |>
  summarise(
    n             = n(),
    media_imc     = round(mean(BMI, na.rm = TRUE), 1),
    media_colest  = round(mean(Cholesterol, na.rm = TRUE), 1),
    media_presion = round(mean(BloodPressure, na.rm = TRUE), 1),
    .groups       = "drop"    # siempre a√±adir: limpia los grupos residuales
  )
```

> ‚ö†Ô∏è **Buena pr√°ctica:** siempre a√±ade `.groups = "drop"` al final de `summarise()` cuando usas `group_by()`. Si no, el resultado sigue agrupado y puede causar comportamientos inesperados.

## Agrupar por varias columnas

```{r}
# Indicadores por tipo de residencia Y nivel educativo
salud |>
  group_by(ResidenceType, EducationLevel) |>
  summarise(
    n           = n(),
    media_imc   = round(mean(BMI, na.rm = TRUE), 1),
    media_edad  = round(mean(Age, na.rm = TRUE), 1),
    .groups     = "drop"
  ) |>
  arrange(ResidenceType, EducationLevel)
```

## `count()` ‚Äî El atajo m√°s √∫til

```{r}
# Estas dos instrucciones producen el mismo resultado:
salud |> group_by(SmokingStatus) |> summarise(n = n(), .groups = "drop")

# Atajo:
salud |> count(SmokingStatus, sort = TRUE)
```

## An√°lisis real: ¬øLos fumadores tienen mayor riesgo cardiovascular?

```{r}
salud |>
  filter(!is.na(SmokingStatus)) |>
  group_by(SmokingStatus) |>
  summarise(
    n                  = n(),
    media_presion      = round(mean(BloodPressure, na.rm = TRUE), 1),
    media_colesterol   = round(mean(Cholesterol, na.rm = TRUE), 1),
    media_riesgo_cardio = round(mean(riesgo_cardio, na.rm = TRUE), 1),
    pct_obesidad       = round(mean(BMI >= 30, na.rm = TRUE) * 100, 1),
    .groups            = "drop"
  ) |>
  arrange(desc(media_riesgo_cardio))
```

## Perfil por nivel educativo

```{r}
perfil_educacion <- salud |>
  filter(!is.na(EducationLevel)) |>
  group_by(EducationLevel) |>
  summarise(
    n               = n(),
    media_imc       = round(mean(BMI, na.rm = TRUE), 1),
    media_estres    = round(mean(StressLevel, na.rm = TRUE), 1),
    media_sue√±o     = round(mean(SleepHours, na.rm = TRUE), 1),
    .groups         = "drop"
  ) |>
  arrange(desc(media_imc))

perfil_educacion
```

```{r}
#| fig-align: center
#| out-width: "85%"

# Visualizamos IMC promedio por nivel educativo
perfil_educacion |>
  filter(!is.na(EducationLevel)) |>
  ggplot(aes(x = reorder(EducationLevel, media_imc), y = media_imc, fill = media_imc)) +
  geom_col(show.legend = FALSE) +
  geom_text(aes(label = media_imc), hjust = -0.2, size = 3.5) +
  coord_flip() +
  scale_fill_gradient(low = "#74c0fc", high = "#e03131") +
  labs(
    title    = "IMC promedio por nivel educativo",
    subtitle = "Dataset de indicadores de salud",
    x        = NULL,
    y        = "IMC promedio"
  ) +
  theme_minimal(base_size = 12) +
  xlim(NA, max(perfil_educacion$media_imc, na.rm = TRUE) * 1.1)
```

---

::: {.callout-note icon=false}
## üèãÔ∏è Ejercicios ‚Äî `group_by()` + `summarise()`

**1.** ¬øCu√°l es el promedio de horas de sue√±o por tipo de residencia?

**2.** ¬øQu√© estado civil tiene el nivel de estr√©s m√°s alto en promedio?

**3.** Calcula el promedio de glucosa y colesterol por estatus de tabaquismo.

**4. Desaf√≠o:** ¬øEn qu√© combinaci√≥n de `EducationLevel` y `ResidenceType` se observa el mayor IMC promedio?

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluciones

```{r}
# 1. Horas de sue√±o por residencia
salud |>
  group_by(ResidenceType) |>
  summarise(media_sue√±o = round(mean(SleepHours, na.rm = TRUE), 1), .groups = "drop")

# 2. Estado civil con mayor estr√©s
salud |>
  filter(!is.na(MaritalStatus)) |>
  group_by(MaritalStatus) |>
  summarise(media_estres = round(mean(StressLevel, na.rm = TRUE), 1), .groups = "drop") |>
  slice_max(media_estres, n = 3)

# 3. Glucosa y colesterol por tabaquismo
salud |>
  filter(!is.na(SmokingStatus)) |>
  group_by(SmokingStatus) |>
  summarise(
    media_glucosa    = round(mean(Glucose, na.rm = TRUE), 1),
    media_colesterol = round(mean(Cholesterol, na.rm = TRUE), 1),
    .groups          = "drop"
  )

# 4. Educaci√≥n + residencia con mayor IMC
salud |>
  group_by(EducationLevel, ResidenceType) |>
  summarise(media_imc = round(mean(BMI, na.rm = TRUE), 1), n = n(), .groups = "drop") |>
  filter(!is.na(EducationLevel), !is.na(ResidenceType)) |>
  slice_max(media_imc, n = 5)
```
:::

---

# Joins ‚Äî Combinar tablas

Muchas veces la informaci√≥n est√° en tablas separadas. Los **joins** las unen usando una columna llave en com√∫n.

Con nuestro dataset de salud, un escenario frecuente es tener **dos tablas derivadas del mismo dataset** que queremos cruzar: por ejemplo, los registros individuales junto con un resumen por grupo.

## `left_join()` ‚Äî El join m√°s usado

Construimos dos tablas y las unimos:

```{r}
# Tabla 1: registros individuales con variables clave
detalle_individual <- salud |>
  select(ID, SmokingStatus, ResidenceType, Age, BMI, Cholesterol)

# Tabla 2: resumen de indicadores por tipo de residencia
resumen_residencia <- salud |>
  group_by(ResidenceType) |>
  summarise(
    imc_promedio_zona       = round(mean(BMI, na.rm = TRUE), 1),
    colesterol_promedio_zona = round(mean(Cholesterol, na.rm = TRUE), 1),
    n_en_zona               = n(),
    .groups                 = "drop"
  )

# Vista r√°pida de cada tabla
head(detalle_individual, 3)
resumen_residencia
```

`left_join()` conserva **todas las filas** de la tabla izquierda y agrega las columnas de la derecha donde encuentra coincidencia en la llave (`ResidenceType`):

```{r}
# Para cada participante, agregamos el contexto promedio de su zona de residencia
detalle_con_contexto <- detalle_individual |>
  left_join(resumen_residencia, by = "ResidenceType")

detalle_con_contexto |>
  select(ID, ResidenceType, BMI, imc_promedio_zona, n_en_zona) |>
  head(8)
```

Ahora podemos calcular si cada participante est√° por encima o por debajo del promedio de su zona:

```{r}
detalle_con_contexto |>
  mutate(
    diferencia_imc = round(BMI - imc_promedio_zona, 2)
  ) |>
  filter(!is.na(diferencia_imc)) |>
  select(ID, ResidenceType, BMI, imc_promedio_zona, diferencia_imc) |>
  arrange(desc(diferencia_imc)) |>
  head(8)
```

## Los 4 joins principales

Para ilustrar las diferencias, usamos dos subconjuntos: participantes fumadores y participantes con posgrado. No todos los IDs aparecen en ambos grupos.

```{r}
# IDs de participantes que fuman
fumadores <- salud |>
  filter(SmokingStatus == "Fuma") |>
  select(ID, SmokingStatus, Age) |>
  slice_head(n = 6)

# IDs de participantes con posgrado (y su IMC)
posgrado <- salud |>
  filter(EducationLevel == "Posgrado") |>
  select(ID, EducationLevel, BMI) |>
  slice_head(n = 6)
```

::: columns
::: {.column width="50%"}
`fumadores` (6 participantes que fuman)
```{r echo=FALSE}
fumadores
```
:::
::: {.column width="50%"}
`posgrado` (6 participantes con posgrado)
```{r echo=FALSE}
posgrado
```
:::
:::

```{r}
# inner_join: solo IDs que aparecen en AMBAS tablas
inner_join(fumadores, posgrado, by = "ID")
```

```{r}
# left_join: todos los fumadores; NA donde no tienen posgrado
left_join(fumadores, posgrado, by = "ID")
```

```{r}
# anti_join: fumadores que NO tienen posgrado
anti_join(fumadores, posgrado, by = "ID")
```

### ¬øCu√°ndo usar cada uno?

| Join | Resultado | √ösalo cuando... |
|---|---|---|
| `inner_join` | Solo filas con coincidencia en ambas tablas | Solo te interesan las coincidencias |
| `left_join` | Todas las filas de la tabla izquierda | Quieres enriquecer tu tabla principal sin perder filas |
| `right_join` | Todas las filas de la tabla derecha | Igual que left pero invirtiendo el orden |
| `full_join` | Todas las filas de ambas tablas | Quieres ver todo, con NA donde no hay coincidencia |
| `anti_join` | Filas de la izquierda SIN coincidencia | Quieres encontrar qu√© falta o qu√© no coincide |

> üí° **`left_join()`** es el join m√°s usado: no pierdes ninguna fila de tu tabla principal.

---

# Funciones de ventana

Las funciones de ventana calculan un valor por fila usando informaci√≥n de **otras filas del mismo grupo**, sin colapsar. Son ideales para rankings y comparaciones.

## Ranking dentro de grupos: `dense_rank()`

```{r}
# ¬øQui√©nes tienen el mayor IMC dentro de cada grupo de tabaquismo?
salud |>
  filter(!is.na(SmokingStatus), !is.na(BMI)) |>
  group_by(SmokingStatus) |>
  mutate(ranking_imc = dense_rank(desc(BMI))) |>
  filter(ranking_imc <= 3) |>
  select(ID, SmokingStatus, BMI, ranking_imc) |>
  arrange(SmokingStatus, ranking_imc)
```

## Comparar cada fila con el promedio del grupo

```{r}
# Para cada participante: ¬øcu√°nto se aleja su colesterol del promedio de su grupo educativo?
salud |>
  filter(!is.na(EducationLevel)) |>
  group_by(EducationLevel) |>
  mutate(
    promedio_educacion = round(mean(Cholesterol, na.rm = TRUE), 1),
    diferencia         = round(Cholesterol - promedio_educacion, 1)
  ) |>
  ungroup() |>
  filter(diferencia > 30) |>
  select(ID, EducationLevel, Cholesterol, promedio_educacion, diferencia) |>
  arrange(desc(diferencia)) |>
  head(8)
```

## `lag()` ‚Äî Comparar registros consecutivos

```{r}
# Diferencia de IMC entre registros consecutivos (ordenados por edad)
salud |>
  filter(!is.na(Age), !is.na(BMI)) |>
  arrange(Age) |>
  mutate(
    diferencia_imc_anterior = round(BMI - lag(BMI), 2)
  ) |>
  select(ID, Age, BMI, diferencia_imc_anterior) |>
  head(10)
```

---

# Verbos adicionales

## `across()` ‚Äî Aplicar una funci√≥n a muchas columnas

```{r}
# Promedio de TODAS las variables num√©ricas agrupado por estatus de tabaquismo
salud |>
  filter(!is.na(SmokingStatus)) |>
  group_by(SmokingStatus) |>
  summarise(
    across(where(is.numeric), ~ round(mean(.x, na.rm = TRUE), 1)),
    .groups = "drop"
  ) |>
  select(SmokingStatus, Age, BMI, Cholesterol, BloodPressure, Glucose)
```

## `slice_max()` / `slice_min()` ‚Äî Top N por grupo

```{r}
# El participante con mayor IMC por tipo de residencia
salud |>
  filter(!is.na(ResidenceType), !is.na(BMI)) |>
  group_by(ResidenceType) |>
  slice_max(BMI, n = 1) |>
  select(ID, ResidenceType, BMI, Age, SmokingStatus) |>
  arrange(desc(BMI))
```

## `distinct()` ‚Äî Valores √∫nicos

```{r}
# ¬øCu√°ntos niveles educativos distintos hay?
salud |>
  distinct(EducationLevel) |>
  arrange(EducationLevel)
```

---

# Caso integrador: an√°lisis completo del dataset de salud

Combinamos todo lo aprendido para responder preguntas concretas con datos reales.

## Pregunta 1: ¬øExisten diferencias de riesgo cardiovascular entre tipos de residencia?

```{r}
riesgo_residencia <- salud |>
  filter(!is.na(ResidenceType)) |>
  group_by(ResidenceType) |>
  summarise(
    n                    = n(),
    media_riesgo_cardio  = round(mean(riesgo_cardio, na.rm = TRUE), 1),
    media_presion        = round(mean(BloodPressure, na.rm = TRUE), 1),
    media_colesterol     = round(mean(Cholesterol, na.rm = TRUE), 1),
    pct_obesidad         = round(mean(BMI >= 30, na.rm = TRUE) * 100, 1),
    .groups              = "drop"
  ) |>
  arrange(desc(media_riesgo_cardio))

riesgo_residencia
```

## Pregunta 2: ¬øC√≥mo se distribuye el IMC por tabaquismo y nivel educativo?

```{r}
#| fig-align: center
#| out-width: "85%"

salud |>
  filter(!is.na(SmokingStatus), !is.na(EducationLevel), !is.na(BMI)) |>
  group_by(SmokingStatus, EducationLevel) |>
  summarise(
    media_imc = round(mean(BMI, na.rm = TRUE), 1),
    n         = n(),
    .groups   = "drop"
  ) |>
  ggplot(aes(x = EducationLevel, y = media_imc, fill = SmokingStatus)) +
  geom_col(position = "dodge", alpha = 0.85) +
  scale_fill_manual(
    values = c("Fuma" = "#e03131", "No fuma" = "#2f9e44", "Ex-fumadora" = "#f08c00")
  ) +
  labs(
    title    = "IMC promedio por nivel educativo y estatus de tabaquismo",
    subtitle = "Dataset de indicadores de salud",
    x        = "Nivel educativo",
    y        = "IMC promedio",
    fill     = "Tabaquismo"
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")
```

---

# Resumen de los 6 verbos

| Verbo | ¬øQu√© hace? | Equivalente en R base |
|---|---|---|
| `filter()` | Filtra filas por condici√≥n | `df[condici√≥n, ]` |
| `select()` | Elige columnas | `df[, c("col")]` |
| `arrange()` | Ordena filas | `df[order(...), ]` |
| `mutate()` | Crea / modifica columnas | `df$nueva <- ...` |
| `summarise()` | Resume a estad√≠sticos | `mean()`, `sum()`, etc. |
| `group_by()` | Agrupa para operaciones por grupo | `tapply()`, `aggregate()` |

El **pipe `|>`** une todos estos verbos de forma legible, de arriba a abajo.

---

::: {.callout-note icon=false}
## üèÜ Ejercicio integrador final

Usando el dataset `salud`, responde las siguientes preguntas **en un solo bloque de c√≥digo encadenado con pipes**:

**A)** ¬øCu√°l es el promedio de estr√©s y horas de sue√±o por tipo de residencia y estado civil? Ordena de mayor a menor estr√©s. Incluye solo grupos con al menos 1 observaci√≥n.

**B)** ¬øQui√©nes son los 5 participantes con mayor diferencia entre su IMC y el IMC promedio de su grupo educativo? Muestra su ID, educaci√≥n, IMC y la diferencia.

:::

::: {.callout-tip icon=false collapse=true}
## ‚úÖ Soluci√≥n del ejercicio integrador

```{r}
# A) Estr√©s y sue√±o por residencia y estado civil
salud |>
  filter(!is.na(ResidenceType), !is.na(MaritalStatus)) |>
  group_by(ResidenceType, MaritalStatus) |>
  summarise(
    n             = n(),
    media_estres  = round(mean(StressLevel, na.rm = TRUE), 1),
    media_sue√±o   = round(mean(SleepHours, na.rm = TRUE), 1),
    .groups       = "drop"
  ) |>
  filter(n >= 1) |>
  arrange(desc(media_estres))

# B) Top 5 con mayor desv√≠o de IMC respecto a su grupo educativo
salud |>
  filter(!is.na(EducationLevel), !is.na(BMI)) |>
  group_by(EducationLevel) |>
  mutate(
    imc_promedio_educacion = round(mean(BMI, na.rm = TRUE), 1),
    diferencia_imc         = round(abs(BMI - imc_promedio_educacion), 2)
  ) |>
  ungroup() |>
  slice_max(diferencia_imc, n = 5) |>
  select(ID, EducationLevel, BMI, imc_promedio_educacion, diferencia_imc)
```
:::

---

# Pr√≥ximos pasos {.unnumbered}

Una vez que domines estos verbos, el camino natural dentro del ecosistema tidyverse es:

- **`tidyr`** ‚Äî transformar la forma de las tablas (`pivot_wider`, `pivot_longer`)
- **`stringr`** ‚Äî manipular texto y cadenas de caracteres
- **`lubridate`** ‚Äî trabajar con fechas y tiempos
- **`ggplot2`** ‚Äî visualizaci√≥n de datos (que ya usamos en este tutorial)

Todo con la misma filosof√≠a: c√≥digo que se lee de arriba a abajo, verbos expresivos y pipes que conectan las operaciones.
